"""
This script compares the luminosity functions generated by
in the standard way, and by assuming the FRBs and beamshape are
at beam centre (generated via running beam_effect_vvmax.py)

"""


import numpy as np
from matplotlib import pyplot as plt
from scipy.optimize import curve_fit
from scipy.integrate import quad
from scipy import stats
from RLFs import *

global E0
# normalisation energy - no physical meaning, just makes units more sensible
E0=1e22


import matplotlib
#matplotlib.rcParams['image.interpolation'] = None
defaultsize=16
ds=4
font = {'family' : 'Calibri',
        'weight' : 'normal',
        'size'   : defaultsize}
matplotlib.rc('font', **font)

def main(loc=True,plot=True,Truncate=True):
    
    opdir = "v2LumData/v2"
    opdir2 = "MinzOutput/"
    
    # extracts the mean V/Vmax value for these two surveys
    vvmax_data="UnbiasedLocalisedOutput/localised_vvmax_data_NSFR_0.0_alpha_0.dat"
    vvmaxbar = get_vvmax(vvmax_data)
    print("Unbiased localised vvmax bar is ",vvmaxbar)
    
    ### infiles
    savefiles = [
        "UnbiasedLocalisedLumData/localised_vvmax_data_NSFR_0.0_alpha_0.npz",
        "BeamCentreUnbiasedLocalisedLumData/localised_vvmax_data_NSFR_0.0_alpha_0.0.npz"
        ]
        
    if Truncate:
        # ensures only two lines are plotted
        savefiles = savefiles[0:2]
        
        
    labels = [
        "$z_{\\rm loc}; z_{\\rm lim}=0.7$",
        "Top-hat beamshape"
        ]
    
        
    linestyles = ["--",":","-."]
    markers = ['+','s','o','x','^']
    
    plt.figure()
    
    for i,savefile in enumerate(savefiles):
        data=np.load(savefile)
        bcs = data['bin_centres']
        h = data['histogram']
        MCbounds = data['MCerror']
        fit = data['Schechter']
        fiterr = data['Serr']
        chi2 = data['Schi2']
        Nfrb = data['Nfrb']
        PLfit = data['PowerLaw']
        PLerr = data['PLerr']
        PLchi2 = data['plchi2']
        ndata = data['ndata']
        
        Ntot = np.sum(Nfrb)
        
        # select bin to normalise to
        ibin = np.where(bcs > 1e23)[0][0]
        norm = h[ibin]
        
        #print(fit[1],fiterr[1],fit[2],fiterr[2])
        
        if i==0 or i==1:#or i==1 or i==2 or i==11:
            print("\n\n#### i is ",i,"   #####")
            Sndf = ndata-3
            PLndf = ndata-2
            Dndf = 1
            pvalue = 1.-stats.chi2.cdf(chi2, Sndf)
            PLpvalue = 1.-stats.chi2.cdf(PLchi2, PLndf)
            
            
            # formula as (SS1-SS2)/(ndf2-ndf1) / (SS2/ndf2)
            Fstat = ((PLchi2-chi2)/Dndf)/(chi2/Sndf)
            Fpvalue = 1.-stats.f.cdf(Fstat,1.,Sndf)
            #print("p-value of F-test is ",Fpvalue)
            
            
            print("Power-law best fits:")
            string = "& {0:1.2f} $\pm$ {1:1.2f} & N/A & {2:1.2f} & {3:1.2f}"\
                .format(PLfit[0],PLerr[0],PLchi2/PLndf,PLpvalue)
            print(string)
            #print("chi2 for power-law fit is ",PLchi2," (pvalue ",PLpvalue,")")
            #print("slope of power-law is ",PLfit[0]," +- ",PLerr[0])
            
            print("Schechter function best fits:")
            string = "& {0:1.2f} $\pm$ {1:1.2f} & {2:1.2e} $\pm$ {3:1.2e} & {4:1.2e} & {5:1.2e}"\
                .format(fit[1],fiterr[1],fit[2],fiterr[2],chi2/Sndf,Fpvalue)
            print(string)
            
        if plot:
            if i==0:
                l1=plt.errorbar(bcs,h/norm,yerr = MCbounds/norm,linestyle="",marker=markers[i],label=labels[i])
                l11,=plt.plot(bcs,integrateSchechter(bcs,*fit)/norm,
                    color=plt.gca().lines[-1].get_color(),linestyle="-",label=labels[i]+"(fit)")
            elif i==1:
                l2=plt.errorbar(bcs,h/norm,yerr = MCbounds/norm,linestyle="",marker=markers[1],label=labels[i])
                l22,=plt.plot(bcs,integrateSchechter(bcs,*fit)/norm,
                    color=plt.gca().lines[-1].get_color(),linestyle="-.",label=labels[i]+"(fit)")

    
    #handles, labels = plt.gca().get_legend_handles_labels()
    #handles.append(handles[0])
    #handles=handles[1:]
    #labels.append(labels[0])
    #labels=handles[1:]
    
    if plot:
        plt.xlabel('$E_{\\nu}$ [J Hz$^{-1}$]')
        plt.ylabel('$E_{\\nu}\\,  {\\rm RLF}(E_{\\nu})$ [arb. units]')
        plt.xscale('log')
        plt.yscale('log')
        #plt.ylim(1e-9,0.002)
        
        
        plt.xlim(2e23,4e26)
        plt.ylim(1e-2,2)
        
        # original version with 4 lines
        if Truncate:
            plt.legend(loc="upper right",frameon=False,handles=[l11,l22])
        else:
            plt.legend(loc="upper right",frameon=False,handles=[l11,l22,l33,l44])
        
        plt.tight_layout()
        plt.savefig("beam_effect_zoom_paper_luminosity_unbiased.pdf")
        plt.close()
    

def get_vvmax(datafile):
    """
    Loads data and gets mean vvmax value
    """
    data  = np.loadtxt(datafile)
    
    vvmax = data[:,6]
    vvmaxbar = np.sum(vvmax)/vvmax.size
    return vvmaxbar

main()
